## 가상 DOM

- 실제 브라우저의 DOM이 아닌 **리액트 관리하는 가상의 DOM**
- 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고
  - 리액트가 실제 변경에 대한 준비가 완료됐을 때
  - 실제 브라우저의 DOM에 반영한다.

### 만들어진 이유

문제

- 브라우저의 렌더링 비용은 복잡하고 많은 비용이 든다.
- 또한 렌더링 완료 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황도 고려해야 한다.
- 인터랙션에 따라 DOM의 모든 변경 사항을 추적하기는 너무 수고스러운 일
- 대부분 개발자는 인터랙션에 모든 DOM의 변경보다는 **결과적으로 만들어지는 DOM 결과물 하나만** 알고 싶을 것

그래서 이런 문제를 해결하기 위해 탄생한 것이 바로 **가상 DOM**

## 리액트는 어떻게 가상 DOM을 만드나?

가상 DOM과 렌더링 최적화를 가능하게 해주는 것이 바로 리액트 파이버(React Fiber)

### 리액트 파이버

- 리액트에서 관리하는 평범한 자바스크립트 객체
- 파이버는 파이버 재조정자(Fiber Reconciler)가 관리
  - 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 이 둘 사이에 차이가 있으면
    **변경에 관련된 정보를 가지고 있는 파이버**를 기준으로 화면에 렌더링을 요청하는 역할을 한다
- 파이버의 목표
  - 리액트 웹 애플리케이션에서 발생하는
    - 애니메이션, 레이아웃, 사용자 인터랙션에
    - 올바른 결과물을 만드는 반응성 문제를 해결하는 것
- 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만,
- 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어
- 이후에 가급적이면 재사용된다.

> 재조정 (Reconciliation)
> 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

#### 파이버의 작업 과정

- 작업을 작은 단위로 분할하고 쪼갠 다음, **우선순위**를 매긴다.
- 이러한 작업을 **일시 중지**하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 **재사용**하거나 필요하지 않다면 **폐기**할 수 있다.

이 모든 과정은 **비동기**로 일어난다.

#### 과거 리액트 조정 알고리즘

- 스택 알고리즘
- 렌더링에 필요한 작업들이 쌓이면 스택이 빌 때까지 동기적으로 작업이 이루어졌다.
- 자바스크립트의 싱글 스레드라는 특징으로 인해 동기 작업은 중단될 수 없고,
  - 다른 작업이 수행되고 싶어도 중단할 수 없었다.
- 자동 검색을 `input`에서 사용자가 검색어를 타이핑하면,
  - 검색 네트워크 요청
  - 로딩 스피너
  - 관련된 UI 변경
- 사용자가 입력할 때마다 스택에 쌓이고, 동기식으로 처리하기 때문에 글자 입력에 지연이 발생할 수 있다.

이러한 렌더링 스택의 비효율성을 타파하기 위해 스택 조정자 대신 파이버라는 개념이 탄생

#### 파이버는 어떻게 구현돼 있을까?

- 하나의 작업 단위로 구성

1. 리액트는 이러한 작업 단위(파이버)를 하나씩 처리하고 `finishedWork()` 라는 작업으로 마무리
2. 그리고 이 작업을 커밋해서
3. 실제 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다.

이 단계를 두 단계로 나눌 수 있다.

0. 파이버의 작업, 우선순위를 지정 or 중지 or 버리는 등의 작업이 발생
1. 렌더 단계
   - 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다.
2. 커밋 단계
   - DOM에 실제 변경 사항을 반영하기 위한 작업
   - `commitWork()`가 실행되고
   - 동기식으로 일어나고 중단될 수도 없다.

## 파이버 트리

파이버 트리는 리액트 내부에서 2개가 존재

- Current Tree
- WorkInProgress Tree

리액트 파이버 작업이 끝나면 더블 버퍼링 기법을 사용한다.

- 리액트는 단순히 포인터만 변경해 workInProgress -> current 트리로 바꿔버린다.

#### `setState` 등으로 업데이트가 발생하면?

최초 렌더링이 된 상태 - 이미 리액트는 생성된 `current` 트리가 존재한다. - 파이버도 생성되어 있음

1. `setState`로 인한 업데이트 요청을 받아 `WorkInProgress` 트리를 다시 빌드한다.
2. 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.
   (파이버가 이미 존재하므로 새로 생성하지 않고)
3. `workInProgress` 트리가 UI에 최종적으로 렌더링되어 반용이 완료되면
4. `current`가 `workInProgress`로 변경된다.

리액트 애플리케이션에서는 이렇게 트리를 비교해서 업데이트하는 작업은 시도 때도 없이 일어난다.

이러한 반복적인 재조정 작업 때마다 새로운 파이버 자바스크립트 객체를 만드는 것은 리소스 낭비

따라서 객체를 새롭게 만들기보다는 **기존에 있는 객체를 재활용**하기 위해
내부 속성값만 초기화허간 바꾸는 형태로 트리를 업데이트한다.

그리고 4번은 과거 동기식이고 중단될 수 없었다.
그러나 현재는 우선순위가 높은 다른 업데이트가 오면 일시 중단하거나 새롭게 만들거나 폐기할 수도 있다.

## 파이버와 가상 DOM

- 리액트 컴포넌트에 대한 1:1 정보를 가지고 있는 파이버는 리액트 내부에서 비동기로 이뤄진다.
- 반면,
- 실제 DOM에 반영하는 것은 동기적으로 일어나야 하고
- 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로
- 이러한 작업을 가상에서, 즉 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것
  -> 쉽게 말하면 UI가 지지고 볶고 변경되는 과정을 보여주는 오픈키친이 아니라
  -> 다 만든 요리만 보여주는 것

따라서 파이버와 가상 DOM은 다른 개념이다.

## 가상 DOM과 리액트의 핵심

- 브라우저와 DOM을 더욱 빠르게 그리고 반영하는 것 ❌
- 값으로 UI를 표현하는 것 ✅
  - 화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고
  - 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심

Q. 가상 DOM이 왜 만들어졌나요?

Q. 실제 DOM과는 어떤 차이가 있나요?

Q. 실제 DOM을 조작하는 것보다 실제로 빠른가요?

Q. 반응성?

---

참고

- 모던 리액트 Deep Dive
