리액트에서 함수형 컴포넌트와 훅을 작성하다 보면 의존성 배열(dependencies)에 대한 고민을 한다. 보통 `eslint-react-config`에서 선언돼 있는 `react-hooks/exhaustive-deps`의 도움을 받아 의존성 배열을 채우곤 한다.

Q. 해당 린트의 작동 원리를 이해하는가?

Q. 왜 변수들을 넣어야 하는 지 이해하는가?

해당 린트의 작동 원리를 알기 위해 **자바스크립트의 동등 비교**에 대해 알아야 한다.

- 리액트의 가상 DOM과 실제 DOM의 비교
- 리액트 컴포넌트가 렌더링할 지를 판단하는 방법
- 변수나 함수의 메모이제이션

이 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

## 1.1 props의 동등 비교

컴포넌트의 렌더링이 일어나는 이유 중 하나는 **props의 동등 비교**에 따른 결과다.
props의 동등 비교는 **객체의 얕은 비교**를 기반으로 이루어 진다.

Q. 컴포넌트의 렌더링이 일어나는 이유 중 하나를 설명해라
prop의 동등 비교에 따른 결과

Q. 객체의 얕은 비교가 리액트에서 어떻게 작동하는 지 이해하는가?

> React에서 '객체의 얕은 비교'는 주로 컴포넌트의 `props` 변경을 감지하는 데 사용됩니다. 이 과정에서 `shallowEqual()` 함수가 핵심적인 역할을 합니다. 이 함수는 두 객체의 최상위 수준의 속성들을 비교하여, 그 값들이 동일한지 여부를 판단합니다. 중요한 점은, 이 비교는 객체의 '참조'가 아닌, 실제 속성 값들에 기반한다는 것입니다.
>
> `shallowEqual()`은 각 최상위 속성에 대해 `Object.is()`를 사용하여 동등성을 검사합니다. 이는 중첩된 객체나 배열의 내부까지는 비교하지 않고, 오직 최상위 수준에서만 비교를 수행한다는 의미입니다. 이 방식은 React의 렌더링 성능을 최적화하는 데 중요한 역할을 하며, 불필요한 렌더링을 방지합니다. 예를 들어, `props`가 변경되지 않았다면, React는 해당 컴포넌트의 렌더링을 건너뛸 수 있습니다. 따라서, 효율적인 컴포넌트 업데이트를 위해 `props`의 구조를 간단하게 유지하는 것이 중요합니다.

## 1.2 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 갖고 있다.

### 1.2.1 원시 타입 (Primitive Type)

- 객체가 아닌 모든 타입
- 객체가 아니므로 메서드를 갖지 않는다.

원시 타입에서 특별한 타입은 `null`이다.

```js
typeof null === 'object' // ture
```

`null`의 타입을 검사하면 `object`라는 결과가 반환된다.
이유: 초창기 자바스크립트가 **값을 표현하는 방식** 때문에 발생한 문제이다.

이후에 `typeof null`을 진짜 `null`로 표현하고자 하는 시도가 있었으나 이전 코드에서 작동할 수 없는 호환성이 깨지는 [변경 사항(breaking changes)이어서 받아들여지지 않았다.](https://2ality.com/2013/10/typeof-null.html)

**Number, BigInt**

- `Number`
  - 2의53승 까지만 다룬다.
- `BigInt`
  - `number`가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새롭게 나왔다.

**String**
문자열도 원시 타입으로 **변경 불가능**하다.

```js
const foo = 'bar'

console.log(foo[0]) // 'b'

foo[0] = 'a'

console.log(foo) // 'bar'
```

Q. 작은 따옴표와 큰 따옴표, 백틱의 차이

- 백틱: 같은 문자열을 반환하지만 줄바꿈이 가능하고, 문자열 내부에 표현식을 쓸 수 있다.
- 템플릿 리터럴: 백틱을 사용해서 표현한 문자열

Q. `null`과 `undefined` 차이는?

- `null` 명시적으로 비어 있음을 나타내는 값
- `undefined` 선언됐지만 할당되지 않은 값

**Symbol**

- ES6에서 새롭게 추가된 타입
- **중복되지 않는**, 어떠한 **고유한 값**을 나타내기 위해 만들어졌다.
- 심벌을 생성하려면 반드시 심벌 함수 `Symbol()`을 사용해야만 한다.

```js
// 심벌 함수 내부에 어떤 인자를 넘겨 주어도 동일한 값으로 인정되지 않는다.
const key = Symbol('key')
const key2 = Symbol('key')

key === key2 // false

// 동일한 값을 사용하기 위해서는 Symbol.for를 활용한다.
Symbol.for('hello') === Symbol.for('hello') // true
```

Q. `Symbol()` 활용 사례

### 1.2.2 객체 타입 (Object/Referenece Type)

- 원시 외 모든 것
- 객체, 배열, 함수, 정규식, 클래스
- 객체 타입은 ⭐️**참조를 전달**⭐️한다고 해서 참조 타입이다.
- 여기서 우리가 알아둬야 할 자바스크립트 동등 비교의 특징이 나타난다.

## 1.3 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 바로 값을 저장하는 방식의 차이다.

원시 타입은 불변 형태의 값으로 저장된다. 그리고 이 값은 **변수 할당 시점**에 **메모리 영역**을 차지하고 저장된다.

```js
let gimbap = '김밥'

let bunsik = gimbap

console.log(gimbap === bunsik) // true
```

결과가 `true`가 나오는 이유

- `gimbap`의 '김밥'이라는 값이 `bunsik`에 복사해 전달됐기 때문에 true가 나온다.

반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로

- 원시 값과 다르게 변경 가능한 형태로 저장되며
- 값을 복사할 때도 값이 아닌 **참조**를 전달하게 된다.

```js
let gimbap = {
  default: '원조김밥',
}

let bunsik = {
  default: '원조김밥',
}

// 동등 비교를 하면 false가 나온다.
console.log(gimbap === bunsik) // false

// 원시값인 내부 속성값을 비교하면 동일하다.
console.log(gimbap.default === bunsik.default) // true
```

Q. 위 객체를 동등 비교했을 때 `false`가 나오는 이유

- 객체는 값을 저장하는게 아니라 **참조**를 저장하기 때문에
- 앞서 동일하게 선언했던 객체라 하더라도 저장하는 순간 다른 참조를 바라보기 때문에 `false`를 반환한다.

```js
let gimbap = {
  default: '원조김밥',
}

let bunsik = gimbap

console.log(gimbap === bunsik) // true
```

그러나 위 예시에서는 두 변수가 변수명, 변수명의 주소가 다르지만 `value`가 가리키는 주소가 동일하다. (=동일한 참조를 가진다.)

그래서 true를 반환한다.

따라서 자바스크립트에서 객체 간의 비교가 발생하면

- 육안으로 같아도 내부에서는 다를 수 있고
- 육안으로 달라도 내부에서는 같은 값으로 처리될 수 있다.

Q. 원시 타입과 객체 타입의 가장 큰 차이는?

> 원시 타입은 값을 전달하지만, 객체 타입은 참조를 전달하기 때문에 비교 방식이 다릅니다.
> 같은 값을 가진 객체가 있을 때 육안으로 같아 보여도 내부에서는 다를 수 있고,
> 육안으로 달라도 내부에서는 같은 값으로 처리될 수 있습니다.

Q. 내부에서 처리되는 걸 자세히 말해주세요

> 같은 값을 가진 객체여도 메모리 주소가 다르면 다른 값으로 처리된다는 의미입니다.

Q. 객체의 얕은 비교란?

> 객체의 얕은 비교는 객체의 속성을 하나 하나 비교하는게 아니라, **참조** 자체를 비교한다.

Q. 리액트에서 얕은 비교란?

> 객체의 얕은 비교와는 다르다. 1뎁스까지만 값을 비교한다.
> Object.is()를 기반으로 한 shallowEqaul이라는 자체 비교함수로 비교한다.

https://okky.kr/questions/1432062

---

참고

- 모던 리액트 Deep Dive
