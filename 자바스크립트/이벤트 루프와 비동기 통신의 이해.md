자바스크립트는 **싱글스레드**에서 **동기 방식**으로 동작한다.

> 싱글 스레드
> 한 번에 하나의 작업만 동기적으로 처리할 수 있다.

> 비동기
> 요청을 시작한 후 응답이 오건 말건 상관없이 한 번에 여러 작업을 실행하는 작업 처리 방식

그런데 우리는 자바스크립트에서도 많은 비동기 작업을 하고 있다.

Q. 자바스크립트 환경(싱글스레드)에서 비동기 작업이 가능한 이유
이벤트 루프

## 싱글 스레드

과거에는 프로그램을 실행하는 단위가 오직 **프로세스** 뿐이었다.

> 프로세스
> 프로그램의 상태가 메모리상에서 실행되는 작업

프로그램의 실행은

- 하나의 프로세스를 가지고
- 그 프로세스 내부에서 모든 작업이 처리되는 것을 의미했다.

소프트웨어가 점점 복잡해지면서 하나의 프로그램에서 동시에 여러 개의 작업 수행이 필요해짐

그래서 탄생한 것이

### 스레드

- 하나의 프로세스에서는 여러 개의 스레드를 만들 수 있다.
- 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있다.
- 이에 따라 **프로세스 내부**에서 **여러 개의 스레드를** 활용하면서 동시 다발적인 작업 처리가 가능해졌다.

### 애당초 멀티 스레드로 설계했으면 편한거 아냐?

1. 멀티 스레드는 내부적으로 처리가 복잡하다는 단점이 있다.
   - 스레드는 하나의 프로세스에서 동시에 서로 같은 자원에 접근할 수 있는데,
     동시에 여러 작업을 수행하다 보면 같은 자원에 대해 여러 번 수정하는 등
     **동시성** 문제가 발생할 수 있어 이에 대한 처리가 필요하다.
   - 각각 격리돼 있는 프로세스와는 다르게, 하나의 스레드가 문제가 생기면 같은 자원을 공유하는 다른 스레드에도 동시에 문제가 일어날 수 있다.
2. 과거 자바스크립트 탄생 상황
   브라우저에서 간단한 스크립트 조작만 하려고 탄생하였다. 이렇게 DOM 조작이 복잡해질 것은 고려하지 않음

그래서 자바스크립트가 멀티 스레딩을 지원해서
동시에 여러 스레드를 DOM을 조작한다면?

- **메모리 공유**로 인해 동시에 같은 자원에 접근하면 **타이밍 이슈**가 발생할 수 있다.
- 브라우저의 DOM 표시에 큰 문제를 야기할 수 있다.

## 이벤트 루프

> 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치
> (자바스크립트 런타임 엔진에)

- 이벤트 루프는 호출 스택(Call Stack)이 비어 있는지 여부를 확인한다.

Q. `setTimeout(() => {}, 0)`이 0초 뒤에 실행되는게 보장되지 않는 이유
태스크 큐

## 태스크 큐

> 실행해야할 태스크의 집합

- 이벤트 루프는 1개 이상의 태스크 큐를 가지고 있다.
- 태스크 큐는 자료구조의 큐가 아니라 `set` 형태
  - 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문
  - 실행해야 할 태스크: 비동기 함수의 콜백함수, 이벤트 핸들러 등

1. 이벤트 루프는 호출 스택 비어 있는지 확인
2. 태스크 큐에 대기중인 함수가 있는지 반복해서 확인
   2.1 작업이 있다면 실행 가능한 오래된 것부터 꺼내서 순차적으로 꺼내서 실행
   2.2 여기서 비동기 함수를 꺼내서 실행한다면?

비동기 함수는 누가 수행하느냐?

- n초 뒤에 `setTimeout`을 요청하는 작업은 누가 처리?
- `fetch`를 기반으로 하는 네트워크 요청은 누가 보내고 응답받는가?

이러한 작업들은 동기적으로 실행되는 메인 스레드가 아닌
**태스크 큐가 할당되는 별도의 스레드**에서 실행된다.

- 이 태스큐에 작업을 할당해 처리하는 것은
  - 브라우저나
  - Node.js의 역할

즉, 자바스크립트 코드 실행은 싱글 스레드에서 이루어 지지만
이러한 외부 API 등은 모두 자바스크립트 코드 외부에서 실행되고
콜백이 태스크 큐로 들어가는 것이다.

## 태스크 큐는 어떤 구조로 어떻게 작동할까?

태스크 큐와는 다른 마이크로 태스크 큐라는 것도 있다.
이벤트 루프는 하나의 마이크로 태스크 큐를 가지고 있다.

### 마이크로 태스크 큐

- 기존 태스크 큐보다 우선권을 가진다.

  - `setTimeout`보다 먼저 실행된다.
  - 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미루어진다.

- 태스크 큐: `setTimeout`, `setInterval`, `setImmediate`
- 마이크로 태스크 큐: `Promise`, `process.nextTick`, `queueMicroTask`, `MutationObserver`

## 그렇다면 렌더링은 언제 실행될까?

- 마이크로 태스크 큐 -> 렌더링 -> 태스크 큐
- 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.

```js
const { log } = console

log('a') // 1. 동기적으로 실행

setTimeout(() => {
  log('b')
}, 0) // 3. 태스크 큐에 추가

Promise.resolve().then(() => {
  log('c')
}) // 2. 마이크로 태스크 큐에 추가

window.requestAnimationFrame(() => {
  log('d')
}) // 4. 다음 렌더링 사이클에서 실행
```

- 결과 : a, c, b, d
- 브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에 일어난다.

Q. 이러한 개념에 기반한 렌더링 전략
무거운 작업을 처리하고 UX를 향상시키기 위한 전략:

1. **분할 및 지연 실행 (Chunking and Deferring)**:

   - 무거운 작업을 여러 작은 작업으로 분할하고, `setTimeout` 또는 `requestAnimationFrame`을 사용하여 작업을 여러 렌더링 사이클에 걸쳐 분산시킵니다.
   - 예: 긴 리스트 렌더링, 복잡한 계산 등을 여러 부분으로 나누어 처리합니다.

2. **마이크로 태스크 활용**:

   - `Promise`와 같은 마이크로 태스크는 태스크 큐보다 우선적으로 처리됩니다. 따라서, UI 업데이트와 관련된 작업을 마이크로 태스크로 처리하여 빠르게 반응하게 할 수 있습니다.

3. **비동기 처리**:

   - `Web Workers`를 사용하여 메인 스레드와 별개로 무거운 작업을 처리합니다. 이를 통해 UI 스레드가 블록되지 않고, 사용자 인터랙션에 빠르게 반응할 수 있습니다.

4. **`requestAnimationFrame` 활용**:

   - 애니메이션과 같은 시각적인 업데이트는 `requestAnimationFrame`을 사용하여 처리합니다. 이는 브라우저의 렌더링 사이클과 동기화되어 효율적인 렌더링을 보장합니다.

---

참고

- 모던 리액트 Deep Dive
